<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web3入门—去中心化交易所的部署</title>
      <link href="/2025/12/05/Web3%E5%85%A5%E9%97%A8%E2%80%94%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/12/05/Web3%E5%85%A5%E9%97%A8%E2%80%94%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ERC20代币合约部署"><a href="#一、ERC20代币合约部署" class="headerlink" title="一、ERC20代币合约部署"></a>一、ERC20代币合约部署</h2><blockquote><p>本次代币合约部署过程参考<a href="https://www.wtf.academy/en/course/solidity103/ERC20">https://www.wtf.academy/en/course/solidity103/ERC20</a></p></blockquote><h3 id="ERC20是什么"><a href="#ERC20是什么" class="headerlink" title="ERC20是什么"></a>ERC20是什么</h3><p>​        ERC20是以太坊上的一种代币标准，由Vitalik Buterin于2025年11月提出。它实现了代币转移的基本逻辑：</p><ul><li>账户余额</li><li>转移</li><li>批准转账</li><li>代币总供应量</li><li>令牌信息（optional）：名称、符号、小数</li></ul><p>​        基于此衍生的IERC20规定了代币需要实现的功能和事件，一种接口合约。定义接口的原因在于ERC20代币拥有通用的函数名和输入输出函数；在接口函数中只需要定义函数名和输出输出参数，无需关心函数内部的具体实现方式；因此函数分为内部实现和外部接口两部分，重点在于接口之间共享数据的实现和约定。这就是为什么在合约的实际部署过程之中通常需要ERC20.sol和IERC20.sol来实现一个合约。</p><p>​        Solidity 作为当前社区中一种用于编写以太坊虚拟机 (EVM) 智能合约的主流编程语言，能够帮助我们快速完成本次部署；不过在本次正式开始编写之前，我们还需了解一下OpenZeppelin—覆盖从代币实现到安全工具的Solidity开发标准工具库，其模块化设计有助于我们快速实现安全、标准化的智能合约，同时减少开发和审计的成本。通过合理使用OpenZepplin的模块，可以显著提高合约的安全性。</p><h3 id="编写2个ERC20代币合约"><a href="#编写2个ERC20代币合约" class="headerlink" title="编写2个ERC20代币合约"></a>编写2个ERC20代币合约</h3><p>​        本文中构建的两款具备差异化安全特性的ERC20标准代币MacdonaldA与KFCB，核心目标在于遵循ERC20代币基础规范的同时，针对区块链交易中常见的安全风险引入针对性防护机制。合约开发严格遵守Solidity0.8.20版本语法规范，利用语言内置的溢检查特性替代传统SafeMath库，在精简代码体量的同时保障基础运算的安全准确。</p><p>​         两款代币均通过状态变量完成对核心数据的存储与管理：基础层面，继承自ERC20标准库的内置状态变量（如<code>_balances</code>映射、<code>_totalSupply</code>总量）实现账户余额与代币总供给的记录，<code>_allowance</code>映射则支持代币授权转账功能；在扩展层面MacdonaldA通过<code>_blacklisted</code>映射维护合规黑名单，以<code>MAX_TRANSFER_AMOUNT</code>常量限制单笔转账上限，KFCB通过<code>_timelocks</code>映射为指定账户设置转账时间锁，两类扩展状态变量均与核心交易逻辑深度耦合，形成场景化安全防护。合约构造函数作为初始化入口完成对代币核心信息的定义并初始攻击分配：通过调用ERC20父类构造函数传入代币名称与符号，明确代币身份标识；同时调用<code>_mint</code>函数向合约部署者地址铸造100万枚代币（含18位小数，符合区块链代币通用精度标准）并自动触发ERC20标准的<code>Transfer</code>事件，确保初始分配过程可追溯。</p><p>​        整体交易处理逻辑在继承ERC20标准的<code>_update</code>函数基础上进行安全增强：MacdonaldA重写该函数加入黑名单校验、暂停状态检查及大额转账限制，形成“三重防护”；KFCB通过时间锁校验机制限制处于锁定期的账户发起转账，同时集成ReentrancyGuard库的<code>nonReentrant</code>修饰符，抵御重入攻击。所有安全相关操作均依靠Ownable库实现权限控制，仅合约所有者可执行，确保管理操作的合规性与安全性，具体代码文件已附于附件1，2 。</p><h3 id="应用Remix编译合约"><a href="#应用Remix编译合约" class="headerlink" title="应用Remix编译合约"></a>应用Remix编译合约</h3><p>​        Remix IDE（Remix Ethereum IDE）——以太坊基金会官方维护的开源在线集成开发环境，专为智能合约开发、测试与部署设计，无需本地配置开发环境即可完成从 Solidity 代码编写到区块链部署的全流程操作。考虑到本次实践中的任务规模及便捷程度，使用Remix可以帮助我们节省环境配置时间，其内置的SOlidity编译器也能一站式完成对于我们编写的代币合约的编译、部署与功能测试，因此我们本文中后续有关Solidtiy开发的工作都将在其中进行。</p><p>​         在IDE中完成两份代币合约的编写后，<code>Ctrl+S</code>保存并选择编译器左侧”SOlidity Compiler”中进行编译配置，在”Compiler“下拉菜单中选择0.8.20 版本（Remix将自动加载从Github中加载OpenZepplin合约），完成后分别对两个文件点击 “Solidity Compiler”，出现绿色对勾标志即表示成功编译。</p><p><img src="https://i.postimg.cc/YS5gLXCC/6567b782b7b7146037ae6de16a060c29.png"></p><h3 id="代币合约部署"><a href="#代币合约部署" class="headerlink" title="代币合约部署"></a>代币合约部署</h3><p>​        在以太坊及兼容EVM的区块链中，部署智能合约的本质是向区块两网络中提交一笔【特殊交易】，而钱包是完成这笔交易的核心身份凭证与操作载体。钱包（以MetaMask为例）的核心作用是安全管理私钥——它不会直接暴露私钥，而是通过加密存储、授权签名等方式向区块链节点确认交易确实由地址所有者发起。</p><p>​         部署合约的流程可视为：编译合约—生成字节码—Remix向Metamask发起部署请求—Metamask通过私钥对请求进行签名并广播至区块链网络—节点验证签名合法后执行合约部署逻辑—生成合约地址。</p><p>​         而在合约的部署过程中，考虑到节点的计算、存储、带宽资源等成本，需要消耗对应的Gas(以ETH为单位)，通过支付ETH作为Gas费，向提供计算资源的节点支付报酬，确保合约部署能被全网确认。</p><p>​          在Chorme扩展中安装”Metamask”插件，登录后显示界面，此时钱包内ETH数为0，需要通过复制以太坊钱包地址字符串，进行交易或获取；</p><p><img src="https://i.postimg.cc/QtH3v3Lf/1057112e7b7da6f39adfae9802973137.png"></p><p>​        随后我们在网络中检索faucet发放网站，发现利用谷歌云[<a href="https://cloud.google.com/application/web3/faucet/ethereum/sepolia]%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%EF%BC%8C%E5%A1%AB%E5%86%99%E9%92%B1%E5%8C%85%E5%9C%B0%E5%9D%80%E9%A2%86%E5%8F%960.05">https://cloud.google.com/application/web3/faucet/ethereum/sepolia]可以通过登录账号，填写钱包地址领取0.05</a> ETH&#x2F;d；</p><p><img src="https://i.postimg.cc/t4X8LjWt/c41f336680b7b92ecee7631499750975.png"></p><p>​       返回钱包绑定sepolia后，发现此时ETH已经补充，鉴于合约部署通常gas开销较低，因此基于本次实践的项目体量，可以基于此直接先开展部署。</p><p><img src="https://i.postimg.cc/brnjN9wf/def1a71f48e5aec031ad731408f0ff2a.png"></p><p>​        返回Remix编译器中，点击 “Deploy &amp; run transactions”，环境选择”Injected Provider - MetaMask”，账户填写为对应的以太坊钱包地址，合约选择后点击”Deploy&amp;Verify“开始部署，待Metamask确认完成后，Remix控制台会开始生成交易哈希并等待区块确认，此时**务必记录下每个合约的地址(contact address)**；（图中仅以一个部署为例）</p><blockquote><p>[!CAUTION]</p><p>注意在钱包选择环节记得切换网络，因为它会自动默认连到主网上，需要手动切换到Sepolia  testnet，<strong>部署成功后务必在命令行中点击<code>view on Etherscan</code>不然之后那个官网会不认你，只能重新部署劳财伤神</strong></p></blockquote><p><img src="https://i.postimg.cc/L4kr85Hy/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025_12_05_070025.png"></p><p>待合约部署成功后，可在Metamask中查看gas消耗详情，并通过合约地址导入代币</p><p><img src="https://i.postimg.cc/dtF1Xh1k/740d8863a9875c9bcc54b129f02c5fbc.png"></p><p>利用Etherscan分别对两个代币合约进行查询：</p><p><img src="https://i.postimg.cc/g09C0Z68/397344f3b65fcc38bf201743b38dc4c2.png"></p><p><img src="https://i.postimg.cc/3RDNMpm3/6396ada15af0dac5f590699b0ea49abb.png"></p><h2 id="二、去中心化交易所合约（DEX）"><a href="#二、去中心化交易所合约（DEX）" class="headerlink" title="二、去中心化交易所合约（DEX）"></a>二、去中心化交易所合约（DEX）</h2><blockquote><p>合约详细部署过程参考<a href="https://www.wtf.academy/en/course/solidity103/DEX">https://www.wtf.academy/en/course/solidity103/DEX</a></p></blockquote><p>​         DEX是基于区块链智能合约实现代币点对点交易的金融协议，其核心优势在于无需第三方托管资产、交易透明可追溯，但原生存在前置交易、价格操纵、流动性过度消耗等风险，需通过机制设计弥补链上公开交易与延迟带来的安全漏洞。</p><p>​        1) 因为链上交易的公开可查，套利者便可通过高Gas费插队（MEV），在用户交易前后插入同向&#x2F;反向交易（三明治攻击），从而利用价格波动获利，其攻击背后本质是”交易信息提前泄露与区块链打包顺序可控“。因此，在基础dex合约上，通过引入”Commit-Reveal”机制隔离交易信息，哈希函数抗碰撞性确保承诺不可伪造，延迟期打破套利者信息优势。具体实现为（完整代码见附件3）：</p><ul><li><p>承诺阶段：</p><p>用户提交哈希<code>commithash=keccak256(abi.encodePacked(secret,toeknIn,amountIn,minAmountOut,deadline))</code>（唯一性），将交易细节隐藏；</p></li><li><p>揭示阶段：</p><p>1min延迟后，用户提交secret验证承诺，执行交易；核心约束在于<code>block.timestamp≥commitTime+1min</code>（延迟执行）。</p></li></ul><p>​        2) 也因链上交易存在延迟，因此瞬时大额交易可操纵池内价格，导致用户实际收益低于预期（滑点），这其中的本质在于”CPMM模型下储备金瞬间失衡”，因此通过滑点保护限制最小收益，TWAP通过时间加权平滑价格抵御瞬时操纵；核心公式基于CPMM与加权平均算法，具体实现方式为</p><ul><li><p>滑点保护：</p><p>交易时检验amountOut≥minAmountOut，amountOut由CPMM公式计算得到:</p></li></ul><p>$$<br>amountOut&#x3D;(amountIn×(1-fee)×reverseOut)&#x2F;(reverseIn+amountIn×(1-fee))(fee为交易费率，reverseIn&#x2F;reverseOut为池内储备金)<br>$$</p><ul><li>TWAP检验：</li></ul><p>存储10条历史价格，计算平均加权，权重与时间正相关。约束为|currentPrice-TWAP|&#x2F;TWAP≤5%。</p><blockquote><p>[!NOTE]</p><p><strong>CPMM（恒定乘积做市商模型）</strong>：是DEX中自动做市商（AMM）的核心定价机制，公式为<em>x</em> × <em>y</em> &#x3D; <em>k</em>，其中x和y是流动性池中两种代币的数量，k是定值。现为主流DEX的基础定价模型；</p><p>价格由储备金比例决定，即<br>$$<br>price_{\frac{A}{B}}&#x3D;\frac{y}{x}\space \space<br>$$</p><p>$$<br>amount_{out}&#x3D;\frac{(amount_{in}×y)}{(x+amount_{in})}(交易计算)<br>$$</p><p><strong>TWAP（时间加权平均价格）</strong>，加权平均算法在时间维度上的应用。</p></blockquote><p>​      3)短期的高频套利交易反复消耗池内流动性，导致储备金失衡，交易滑点扩大，其本质是”套利者低成本占用流动性资源“。通过差异化费率提高高频套利成本，经济激励引导长期交易，核心是”行为-费率“联动机制。其约束为fee≤2%；</p><ul><li>费率公式：</li></ul><p>$$<br>fee&#x3D;BASE_{FEE}+penalty(BASE_{FEE}&#x3D;30&#x2F;10000&#x3D;0.3%)<br>$$</p><ul><li>惩罚规则：24小时交易≥3次，fee提升至1%；两次交易间隔&lt;5min，penalty额外加0.2%。</li></ul><p>​        4)LP代币计算：</p><p>​              首次添加：<code>L = √（amountA × amountB）</code>(初始流动性)；</p><p>​              非首次：<code>L = min(amountA × totalSupply/reverseA,amountB × totalSupply/reverseB) </code>（按比例分配，避免失衡。</p><p>​        基于以上，我们部署一个面向区块链生态的安全增强型去中心化交易所（DEX）智能合约，基于Uniswap V2架构开发，针对当前DEX生态中以上列出的风险集成多重安全机制，实现交易安全性与市场效率的平衡。合约以Solidity 0.8.20为开发语言，依托OpenZeppelin安全组件构建权限控制，防重入等安全层，为去中心化交易提供可验证的安全保障。在部署阶段输入前文中部署的两个代币合约地址，之后顺利生成。</p><p><img src="https://i.postimg.cc/vHmskqT5/3dcd121ce253ea6660e261a80ad06be7.png"></p><h3 id="利用DEX进行代币交换"><a href="#利用DEX进行代币交换" class="headerlink" title="利用DEX进行代币交换"></a>利用DEX进行代币交换</h3><blockquote><p>[!TIP]</p><p>进行此步操作前需确保之前的操作都顺利完成，</p><ul><li>Metamask成功连接到DEX合约所在网络</li><li>测试所需ETH足够</li><li>代币合约在初始部署时需拥有至少10个代币A和一定数量的代币B，以用于添加流动性。</li></ul></blockquote><ol><li><p>授权DEX</p><p>​       在Etherscan中搜索代币A的合约地址，进入代币A的合约界面，点击<code>contact</code>→<code>write contact</code>→连接钱包；</p><p><img src="https://i.postimg.cc/sfTXMZZJ/7b5e4155b352bee95bfa8919743a5c34.png"></p><p>​        成功连接后，点击<code>approve</code>函数，输入参数：<code>spender</code>填入DEX合约地址，<code>amount</code>填入10个代币A对应的数值，完成后点击<code>write</code>即钱包确认交易上链，对代币B重复此操作。</p><p><img src="https://i.postimg.cc/FzjrT7Km/ping-mu-jie-tu-2025-12-05-134753.png"><br>在Remix部署界面找到preComputerCommitmentHash，得到commitmentHash，</p></li></ol><p><img src="https://i.postimg.cc/br4ThxKc/bc6855e5db309cdd9169fcc18df91d70.png"></p><p>​        根据<code>deadline</code>（就是时间戳，可从在线网站查看，但由于合约机制需要加预先时间）和<code>commitimenthash</code>，找到<code>CommitSwap</code>函数入口，将得到的结果输入后，可<code>transact</code>，完成初步的Cmmit端，需要保留得到的结果值以备后患；</p><p><img src="https://i.postimg.cc/XqW5c2SM/432ae3b0fc9209c7e57cf94e6e82451d.png"></p><p>解锁交易，DEX扣取tokenA，发放给tokenB，完成交换。在<code>revealSwap</code>函数端，输入先前的<code>secret</code>…（<strong>与步骤1保持一致</strong>），成功上链后，在Etherscan上查看，交易成功。</p><p><img src="https://i.postimg.cc/XJwq3hQV/7226fc39de0883dd5f25bb12fc31aa6a.png"></p><!--需要注意的是，在部署过程中若发现流动性不够导致无法发起解锁，需要在addLiquidity函数中对两个账号中的代币斤进行补充转移，另外若是设置了滑点限制，需要注意限额，避免自己被回滚--><h2 id="三、前端DAPP接入"><a href="#三、前端DAPP接入" class="headerlink" title="三、前端DAPP接入"></a>三、前端DAPP接入</h2><p>当我们全部完成之后，最后选择已部署合约<code>Balance</code>右侧小按钮可快速部署一个个人网站，按照要求输入DEX合约地址，用户名，在compiler页面找到合约的abi，之后选择自己的域名，添加邮箱和密码就成功部署好了！(<a href="https://kerzyaha.surge.sh/">https://kerzyaha.surge.sh/</a>)</p><p><img src="E:\Typora\附件\848bf3deddcec7a0e59aace2bc7aa034.png" alt="848bf3deddcec7a0e59aace2bc7aa034"></p><p><img src="E:\Typora\附件\1e848875d0f1927e415ac1a1f6c6b6f9.png" alt="1e848875d0f1927e415ac1a1f6c6b6f9"></p><h2 id="四、回顾"><a href="#四、回顾" class="headerlink" title="四、回顾"></a>四、回顾</h2><p>在这次实践过程中我多次出现了资源错配以及权限调整，同时对于DEX合约在Etherscan中无法写入的麻烦，在教导下才发现可以在Remix中调用调整，同时通过这次实践是我对区块链入门了解的生动实践，先完成，再完美，脚踏实地，毛躁的性格是做不好事情的反而会把事情拖得效率低下，产出一般；在以后的学习生活中也要积极向组内同学学习，认真高效才是最省力的聪明办法！</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smart contract </tag>
            
            <tag> Dapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学入门——消息认证码</title>
      <link href="/2025/11/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/"/>
      <url>/2025/11/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="加密-完整性"><a href="#加密-完整性" class="headerlink" title="加密&amp;完整性"></a>加密&amp;完整性</h2><h3 id="Goal："><a href="#Goal：" class="headerlink" title="Goal："></a>Goal：</h3><p>在无需保密性的情况下提供完整性，基本机制如MAC（消息认证码）</p><h3 id="MACs"><a href="#MACs" class="headerlink" title="MACs:"></a>MACs:</h3><h5 id="基本组成：（发送方和接收方共享同一密钥k）"><a href="#基本组成：（发送方和接收方共享同一密钥k）" class="headerlink" title="基本组成：（发送方和接收方共享同一密钥k）"></a>基本组成：（发送方和接收方共享同一密钥k）</h5><p>$$<br>S(k,m)\to tag\space \space ;V(k,m,tag)\to ‘yes’&#x2F;‘no’<br>$$<br>$$<br>[其一致性要求为\forall k \in \mathcal{K},m\in \mathcal{M}:V(k,m,S(k,m))&#x3D;’yes’]<br>$$</p><p>若双方不共享同一密钥k，则难以达到完整性目的保障，比如CRC(循环冗余检验)：<br>$$<br>CRC(m)\to tag\space ，Verify(m,tag)\stackrel{?}{&#x3D;} yes<br>$$<br>但是攻击者可以直接拦截并伪造新的消息和验证码，从而破解消息。</p><h5 id="系统安全性（目标）："><a href="#系统安全性（目标）：" class="headerlink" title="系统安全性（目标）："></a>系统安全性（目标）：</h5><p>​        攻击者可以通过m向挑战者寻问其生成的tag，之后攻击者伪造一个新的(m,tag)（优势为挑战者最终输出’yes’的概率大于1&#x2F;2）若攻击者在已知消息-标签对后，无法为同一消息生成一个新的有效的标签，则此系统处于安全状态(<strong><a href="https://www.cnblogs.com/zywnnblog/p/16111384.html">SU-CMA</a></strong>:存在性不可伪造性)；</p><p><img src="https://i.postimg.cc/pTSYqVy6/e2516bb99cf380a599940d4f5f483118.png"></p><p>​       因此为了避免不安全因素（如只有5位mac码情况下，攻击者利用穷举攻击爆破），在构造MAC系统时标签数一般设置为64，96（<a href="https://www.ibm.com/docs/zh/ibm-mq/9.3.x?topic=overview-cryptographic-security-protocols-tls">TLS</a>），128等，以避免过短的标签会因为暴力破解而被爆破。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>​        仅验证文件内容完整性的认证机制（如MAC），虽然能有效防止数据被直接篡改，却无法防御一种更隐蔽的攻击：攻击者可以在不破坏任何认证标签的前提下，将系统中多个经过认证的合法数据进行交换。例如，病毒将两个未被篡改且MAC校验通过的文件互相调换位置，导致系统在加载错误内容时仍无法察觉，从而破坏其正常逻辑。常见的加固方法（如将文件名纳入认证范围）能缓解此问题，但若攻击发生在更高的逻辑层面（如交换经过认证的数据库记录或通信指令），此类基于单个实体的认证机制依然会失效。</p><h3 id="基于PRF-伪随机函数-的MAC构造"><a href="#基于PRF-伪随机函数-的MAC构造" class="headerlink" title="基于PRF(伪随机函数)的MAC构造:"></a>基于PRF(伪随机函数)的MAC构造:</h3><p>$$<br>设定一个PRF(F:k*m \to t)和一个MAC（I_{F}&#x3D;(S,V)）:\<br>其中S(k,m):&#x3D;F(k,m),\space V(k,m,t)\to yes(t&#x3D;F(k,m))&#x2F;no<br>$$</p><p>然而，若对于无论何值都只输出10bit的Tag的随机函数并不安全，因为其仍可有1&#x2F;1024的概率（不可忽略）来穷举爆破，因此对于其安全性的定义如下：<br>$$<br>(EU-CMA)假设对于一个随机函数f:X\to Y,攻击者向挑战者发送m_1,m_2,…,m_q（m\in X），\挑战者向攻击者发送回各自对应的tag，如t_1,t_2,…（t\in Y），之后攻击者发送回一个(m,t*)对，\若t\in Y，且m\notin X，则攻击者获胜，此时的获胜概率最多只有\Pr[A_{win}]&#x3D;\frac{1}{|Y|}\因此我们可以推断出基于PRF的MAC构造中敌手A的优势为Adv_{MAC}[A,I_F]\le Adv_{PRF}[B,F]+\frac{1}{|Y|}\当tag空间足够大时，其(对应的\frac{1}{|Y|})优势可被忽略。<br>$$<br>在一些实际应用中，我们发现AES就是一种16字节输入的MAC（以小消息PRF作为输入），若要构造消息空间大规模GB级别的，有HMAC（如SSL,SSH）和CBC-MAC(常用于银行业，如自动清算系统ACH,用于保证在银行间传输支票等信息的完整性)接受小输入PRF生成大输入PRF。（在实际应用中，我们可以在生成后通过截断，在保证可验证性的基础上减少tag的大小）</p><h3 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h3><h4 id="ECBC"><a href="#ECBC" class="headerlink" title="ECBC:"></a>ECBC:</h4><p>$$<br>设置一个PRP函数(F:K<em>X\to X)，定义新的PRF为（F_{ECBC}:K^2</em>X^{\le L}\to X）<br>$$</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Message Integrity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学入门——流密码</title>
      <link href="/2025/11/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/"/>
      <url>/2025/11/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Welcome!</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream Ciphers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
